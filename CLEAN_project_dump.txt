
===== .\.pre-commit-config.yaml =====
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0 # generic hooks (trailing-whitespace, end-of-file-fixer, etc.)
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files

  - repo: https://github.com/psf/black
    rev: 24.3.0 # Black 24.3.0 supports Python 3.13
    hooks:
      - id: black
        args: [--line-length=88]

  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0 # Flake8 6.1.0 works on 3.13
    hooks:
      - id: flake8
        additional_dependencies:
          - flake8-bugbear==23.12.0
        args:
          - --max-line-length=88
          - --select=E,F,W,B

===== .\CLEAN_project_dump.txt =====

===== .\config.py =====
import os
from datetime import timedelta


base_dir = os.path.abspath(os.path.dirname(__file__))


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY', '')
    PERMANENT_SESSION_LIFETIME = timedelta(minutes=50)
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_SAMESITE = "None"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    CORS_ORIGINS = os.getenv("CORS_ORIGINS", "*")

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get(
        'DEV_DATABASE_URL',
        'sqlite:///' + os.path.join(base_dir, 'instance', 'dev.db')
        )

class ProductionConfig(Config):
    DEBUG = False
    CORS_ORIGINS = os.getenv("CORS_ORIGINS", "")
    SQLALCHEMY_DATABASE_URI = os.environ.get(
        'DATABASE_URL',
        'postgresql+psycopg2://kyle:testpassword@localhost/myflaskdb'
    )

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'

config_map = {
    "development": DevelopmentConfig,
    "production": ProductionConfig,
    "testing": TestingConfig,
}
===== .\dump_clean_code.py =====
import os

# Finalized script to dump clean project files, explicitly ignoring unwanted directories and files.

IGNORE_DIRS = {
    '.git', '.venv', 'venv', '__pycache__', '.mypy_cache', '.idea', '.vscode', 'migrations', 'instance'
}
# Also ignore any directory name containing 'venv' just in case
IGNORE_DIR_KEYWORD = 'venv'

IGNORE_EXTENSIONS = {
    '.pyc', '.log', '.sqlite3', '.db', '.pem', '.key', '.DS_Store', '.cfg', '.so', '.pyd', '.h', '.dll'
}
INCLUDE_EXTENSIONS = {
    '.py', '.html', '.js', '.css', '.md', '.txt', '.json', '.yml', '.yaml', '.env', '.ini'
}

OUTPUT_FILE = "CLEAN_project_dump.txt"

def should_include_file(file_path):
    ext = os.path.splitext(file_path)[1].lower()
    if ext in IGNORE_EXTENSIONS or ext not in INCLUDE_EXTENSIONS:
        return False
    return True

def collect_files(base_dir='.'):
    clean_files = []
    for root, dirs, files in os.walk(base_dir):
        # Normalize dir names for filtering
        filtered_dirs = []
        for d in dirs:
            ld = d.lower()
            if d in IGNORE_DIRS or IGNORE_DIR_KEYWORD in ld:
                continue
            filtered_dirs.append(d)
        dirs[:] = filtered_dirs

        for file in files:
            full_path = os.path.join(root, file)
            # Skip if any part of the path contains ignored dir
            if any(part in IGNORE_DIRS or IGNORE_DIR_KEYWORD in part.lower() for part in full_path.split(os.sep)):
                continue
            if should_include_file(full_path):
                clean_files.append(full_path)
    return clean_files

def dump_files(files, output_path):
    with open(output_path, 'w', encoding='utf-8') as outfile:
        for path in files:
            outfile.write(f"\n===== {path} =====\n")
            try:
                with open(path, 'r', encoding='utf-8') as infile:
                    outfile.write(infile.read())
            except Exception as e:
                outfile.write(f"[Error reading file: {e}]\n")

if __name__ == "__main__":
    print("üì¶ Collecting project files...")
    files = collect_files()
    dump_files(files, OUTPUT_FILE)
    print(f"‚úÖ Done. Output saved to: {OUTPUT_FILE}")


===== .\README.md =====
# üß† FocusFlow Task Manager

A full-stack Flask app with a secure backend and a custom-built JavaScript frontend for managing tasks between users. Supports HTTPS (via mkcert), user auth, CRUD, and clean API design.

---

## Intro

FocusFlow is a simple but secure task management app built from scratch with Flask and vanilla JS. Whether you‚Äôre managing your to-dos or learning how full-stack apps work, this project shows how to build clean APIs, session-based auth, and a custom frontend‚Äîall without using frameworks.

---

## ‚ú® Features

- üîê Secure user login with hashed passwords and session cookies
- üìã Add, edit, and delete tasks in real time (no page reloads)
- üåê HTTPS and CORS setup for secure local dev
- üß™ Unit-tested API endpoints and validation
- üßº Custom script to export clean code dumps for review

---

## üì∏ Screenshots

Screenshots coming soon:

- Login page
- Task dashboard
- Task creation modal
- Mobile layout (if applicable)

---

## üõ†Ô∏è Tech Stack

- **Backend**: Flask, Flask-Login, Flask-Migrate, SQLAlchemy
- **Database**: SQLite
- **Frontend**: Vanilla JavaScript, HTML, CSS
- **Auth**: Session-based with hashed passwords
- **HTTPS**: mkcert-enabled with `.env` cert paths
- **CORS**: Configurable via environment variable
- **Testing**: Python `unittest`

---

## üöÄ Setup Guide

### 0. Install dependencies

```bash
pip install -r requirements.txt
```

---

### 1. Generate a secret key

```bash
python -c "import secrets; print(secrets.token_hex())"
```

Copy it into your `.env`:

```env
SECRET_KEY=your-generated-key
```

---

### 2. Create HTTPS certs (recommended)

**Option A** ‚Äì Quick localhost dev mode:

```bash
mkcert -install
mkcert localhost
```

Add to `.env`:

```env
SSL_CERT=localhost.pem
SSL_KEY=localhost-key.pem
DOMAIN=localhost
```

**Option B** ‚Äì Custom local domain (optional advanced):

1. Edit your `/etc/hosts` or `C:\Windows\System32\drivers\etc\hosts`:

```
127.0.0.1 awa.com
```

2. Run:

```bash
mkcert awa.com "*.awa.com" 127.0.0.1
```

3. Add to `.env`:

```env
DOMAIN=awa.com
SSL_CERT=awa.com.pem
SSL_KEY=awa.com-key.pem
CORS_ORIGINS=https://awa.com:5000
```

---

### 3. CORS Config

Set your expected frontend origin in `.env`:

```env
CORS_ORIGINS=https://localhost:5000
```

---

### 4. Database Migrations

This app uses **Flask-Migrate** to manage database schema changes.

#### üõ† First-time DB Setup:

```bash
flask --app run.py db init
flask --app run.py db migrate -m "initial"
flask --app run.py db upgrade
```

#### üìà After updating `models.py`:

```bash
flask --app run.py db migrate -m "updated schema"
flask --app run.py db upgrade
```

You can commit your `migrations/` folder or let users generate it from models.

---

### 5. Run it

```bash
python run.py
```

---

### 6. Testing

```bash
python -m unittest
```

---

## üì∏ Screenshot

_Coming soon: a visual preview of the app in action._

---

## üí¨ Contact

Built by **Kyle Brougham-Cook**
üíª [LinkedIn](https://linkedin.com/in/kyle-brougham-cook-718b672a4)
üì¨ Open to freelance work, contracts, backend, or remote full-stack roles.

---

## üóÇÔ∏è .env.example

```env
SECRET_KEY=your-secret-key-here
DOMAIN=localhost
SSL_CERT=localhost.pem
SSL_KEY=localhost-key.pem
CORS_ORIGINS=https://localhost:5000
```

===== .\requirements.txt =====
[Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte]

===== .\run.py =====
from focus_flow_app import create_app
from dotenv import load_dotenv
import os

# Loading the .env.example file to populate our app
load_dotenv('.env')


cfg = os.getenv('FLASK_CONFIG', 'development').lower()
app = create_app(cfg)

print("DB URI ‚Üí", app.config["SQLALCHEMY_DATABASE_URI"])


if __name__ == '__main__':

    # Loading everything from the .env.example
    domain = os.getenv("DOMAIN", "localhost")
    port = int(os.getenv("PORT", 5000))
    ssl_cert = os.getenv("SSL_CERT")
    ssl_key = os.getenv("SSL_KEY")



    app.run(
        host=domain,
        port=port,
        ssl_context = (ssl_cert, ssl_key) if ssl_cert and ssl_key else None,
    )
===== .\to-do.txt =====
1. fix get_tasks - found issue - the issue was the damn
validator functions both are inncorrectly flagging | COMPLETED

1.1 - fix the validator_json function. | COMPLETED
1.2 - fix the validator function running on the get_tasks route. | COMPLETED


2. fix failing testing cases -
this is turning out to be harder than suspected im starting to think the issue
is related to the current user part in the route or testing env because
nothing else seems to be wrong im struggling with this one. | COMPLETED

3. fix the issue with a task not being found when trying to delete it immidiately
after creation - i think this might be due to how we are handling task ids...

3.1 i think the issue is when we create tasks we create the dynamic id in logic.js
also i did add an id for the task on the backend so maybe make that work instead of
relying on the frontend to build logic like that...(INPROGRESS)

hmm seems the issue is due to how we are handling the ids of our tasks we need to
make sure the ui task ids arent handling logic like edit or delete because it
wont work... the ui ids need to be incremental while the task_id's need to be fixed
we dont want to query the db constantly either so we need to ensure that we are
building the ui properly while also not messing up the task_id's its likely going
to be neccassary to change the edit, delete and potentually add task logic in logic.js...

we are current working within the task ui builder we got the dbTask logic good for when
it returns just need to work on when it doesnt...


tuesday feels like hell ive added some flags so we can track the task we are currently working within
getTasksLength, i need to fix the issue with the database count skipping one or lagging one the behaviour
is extremely odd if i cant figure it out by hour 1 of backend tomorrow im using gpt to help me track the
issue as it seems to be completely slipping by me at this point, ill try for an hour tomorrow to see if
its simply a foggy mind. (COMPLETED) - pretty sure it was just some weird ass issue when making new tasks
i might be wrong but meh who knows



4. ensure all points are covered in testing (COMPLETED)

5.(COMPLETED) fix the editing feature failure. (COMPLETED) - nah broke again its the ids...
did a lot but need to figure out why the await seems to be failing when grabbing the
latest tasks id from the database...


6. ensure user is logged out upon server shutdown or page close.(COMPLETED)

7. hook up postgreSQL (COMPLETED)


deploy readiness -

1- (DONE) - Fix your ‚ÄúgetTasksLength‚Äù endpoint vs. tests mismatch
2- (DONE) - Clean up your f‚Äëstring quoting in login_page flash
3- (DONE) - Consolidate your config loading
4- (DONE) - Lock down CORS for production
5- () - Polish your templates & UX
6- (DONE) - Normalize your API payloads
7- (DONE) - Improve error messages & status codes
8- () - Add CI & Pre‚ÄëCommit
9- () - Branch strategy & README tweak
10- () - Deployment & demo
===== .\focus_flow_app\models.py =====
from focus_flow_app import db
from flask_login import UserMixin
from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship



# Model for Users
class User(db.Model, UserMixin):
    __tablename__ = "user"

    id = Column(Integer, primary_key=True, nullable=False)
    username = Column(String(150), unique=True, nullable=False)
    password = Column(String(450), nullable=False)
    email = Column(String(150), unique=True, nullable=False)

    tasks = relationship('Task', back_populates='user', lazy='dynamic')



# Model for tasks in the database.
class Task(db.Model):
    __tablename__ = "task"

    id = Column(Integer, primary_key=True, nullable=False)
    user_id = Column(Integer, ForeignKey('user.id', ondelete='CASCADE'), nullable=False)

    name = Column(String(200), nullable=False)
    description = Column(String(350), nullable=True)
    done = Column(Boolean, default=False, nullable=False)

    date = Column(
        DateTime,
        default=datetime.now,
        onupdate=datetime.now,
        nullable=False
    )

    user = relationship('User', back_populates='tasks')



===== .\focus_flow_app\__init__.py =====
import os
from dotenv import load_dotenv
from flask import Flask
from config import config_map
from flask_cors import CORS
from sqlalchemy import select
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from flask_migrate import Migrate



db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()


def create_app(config_name: str | None = None):
    load_dotenv()


    cfg_key = config_name or os.getenv("FLASK_CONFIG", "development")
    cfg_class = config_map.get(cfg_key)
    if not cfg_class:
        raise RuntimeError(f"Unknown FLASK_CONFIG: {cfg_key}")

    app = Flask(__name__, instance_relative_config=False)
    app.config.from_object(cfg_class)


    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login_page' # type: ignore

    CORS(app, supports_credentials=True, origins=app.config["CORS_ORIGINS"])

    from .routes import register_routes
    register_routes(app)



    @login_manager.user_loader
    def load_user(user_id):
        from .models import User
        return db.session.execute(
           select(User).where(User.id == int(user_id))
           ).scalar_one_or_none()




    return app
===== .\focus_flow_app\routes\auth_routes.py =====
from flask import Blueprint, request, render_template, redirect, flash, url_for, jsonify, session
from flask_login import login_user, logout_user, current_user, login_required
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy import select
from ..models import User
from .. import db



auth_bp = Blueprint("auth", __name__, url_prefix="/auth")

@auth_bp.route('/signup', methods=["POST", "GET"])
def create_New_User_Account():
    ''' Our signup route it requires an email, username and password '''
    if request.method == "GET":
        return render_template('signup.html')
    else:
        form = request.form
        expected_keys = ["user_email", "user_name", "user_password"]
        form_data = form.to_dict()


        if not all(key in form_data for key in expected_keys):
            flash("ERROR: INVALID KEY_PAIR RECEIVED! CONTACT AN ADMIN ASAP!")
            return redirect(url_for("auth.login_page")), 422

        if not all(form_data[key].strip() for key in expected_keys):
            flash("ERROR: NO VALUES IN FORM_DATA! CONTACT AN ADMIN ASAP!")
            return redirect(url_for("auth.login_page")), 422

        user = db.session.execute(
            select(User).where(
                (User.email == form.get('user_email').strip()) | # type: ignore
                (User.username == form.get("user_name").strip()) # type: ignore
            )
        ).scalar_one_or_none()

        if user:
            if user.email == form.get("user_email").strip(): # type: ignore
                flash("A User with that Email already exists! Please try again.")
                return redirect(url_for('auth.create_New_User_Account'))

            else:
                flash("A User with that name already exists! Please try again.")
                return redirect(url_for('auth.create_New_User_Account'))
        else:
            new_user = User(
                username = form.get('user_name').strip(), # type: ignore
                password = generate_password_hash(form.get('user_password').strip()), # type: ignore
                email = form.get('user_email').strip() # type: ignore
            )

            db.session.add(new_user)
            db.session.commit()


            login_user(new_user)
            return redirect(url_for("task.view_dashboard"))


@auth_bp.route("/login_page", methods=["POST", "GET"])
def login_page():
    ''' Our login route needs the email and password of the user'''
    if request.method == "GET":
        return render_template("login.html")

    form = request.form
    user = db.session.execute(select(User).where(User.email == form.get("user_email"))).scalar_one_or_none()
    if user != None:
        if not check_password_hash(user.password, form.get("user_password").strip()): # type: ignore
            flash("Incorrect password!")
            return redirect(url_for("auth.login_page"), code=302)
        else:
            login_user(user)
            session.permanent = True
            return redirect(url_for("task.view_dashboard"), code=302)
    else:
        flash(f"A user with the email: {form.get('user_email')} doesn't exist.")
        return redirect(url_for("auth.login_page"), code=302)


@auth_bp.route("/logout", methods=["POST"])
@login_required
def logout():
    ''' Our logout route '''
    flash(f"{current_user.username} was logged out.")
    logout_user()
    return redirect(url_for("auth.login_page"), code=303)


===== .\focus_flow_app\routes\misc_routes.py =====
from flask import Blueprint, render_template  # Web server and helper methods

misc_bp = Blueprint('main', __name__)



@misc_bp.route('/')
def load_landing_page():
    """Serve the main HTML file for the application."""
    # Return the main structure file.
    return render_template('home.html')

===== .\focus_flow_app\routes\task_routes.py =====
from flask import Blueprint, jsonify, request, render_template
from datetime import datetime
from flask_login import current_user, login_required
from ..models import db, Task, User
from .. import login_manager
from sqlalchemy import select, desc


task_bp = Blueprint("task", __name__, url_prefix="/task")


@task_bp.route('/dashboard/view', methods=['GET'])
@login_required
def view_dashboard():
    return render_template('dashboard.html')



@task_bp.route('/dashboard', methods=["GET"])
@login_required
def get_tasks():
    """
    Retrieve all tasks from the database,
    serialize them into JSON, and return.
    """
    tasks = current_user.tasks.all()
    task_list = []
    for task in tasks:
        if validator(task):

            # Serialize each task into a dictionary.
            task_list.append({
                "id": task.id,
                "name": task.name,
                "description": task.description,
                "done": task.done,
                "date": task.date.strftime("%Y-%m-%d %H:%M")
            })
        else:
            return jsonify({"Error": f'The following task: {task} could not be added to the front-end'}), 500
    return jsonify(task_list)


def validator_json(data: dict) -> bool:
    '''This function validates our json data to be added to the database ensuring all needed data is added'''
    # The array to test against for data validation
    required_keys = ['name', 'description']

    # Check all keys are present
    if not all(key in data for key in required_keys):
        return False

    # Check all keys values are of the correct datatype
    if not isinstance(data["name"], str) or not isinstance(data["description"], str):
        return False

    return True



def validator(task: Task) -> bool:
    '''This function validates our task data ensuring no data is missing before sending a task to the front-end

    Args:
        iShort (Bool) : this is for when we only need the name, descripiton and id of a task.

    '''

    elList = [task.user_id, task.name, task.description, task.done, task.date]


    expectedDict = {
        0: int,
        1: str,
        2: str,
        3: bool,
        4: datetime
    }




    # This check is here incase we are dealing with the short version of this
    # function where we only access the first 2/3 elements for validation...
    if len(elList) < 3:
        return False
    elif len(elList) == 3:
        return all(isinstance(item, (str, int)) for item in elList[:3])


    # This part checks that the regular validation logic of the function is expecting
    # the right amount of items to check against...
    for idx in expectedDict.keys():
        if idx > len(elList):
            return False
        else:
            continue


    # This part checks against the expectedDict to ensure we are getting the expected datatypes...
    for keyIdx, value in expectedDict.items():
        if not isinstance(elList[keyIdx], value):
            print(elList[keyIdx], "\n", value)
            return False

    return True


@task_bp.route("/tasks", methods=["POST", "PATCH"]) # type: ignore
@login_required
def add_tasks():
    """
    Add a new task or update an existing task in the database.
    Expects JSON data with task details.
    """

    if request.method == "POST":
        if request.is_json:
            data = request.get_json()
            if validator_json(data):
                new_task = Task(
                    name = data["name"], # type: ignore
                    description = data["description"], # type: ignore
                    user_id = current_user.id, # type: ignore
                )
                db.session.add(new_task)
                db.session.commit()
                return jsonify({"message": "Task added!", "task_id": new_task.id}), 201
            else:
                return jsonify({"error": 'the provided data did not include all required info'}), 422
        else:
            return jsonify({'error': 'there was no json in the response!'}), 400



    elif request.method == "PATCH":
        """
        Update task's name and description using PATCH.
        """
        # We use this list to check for the expected keys we are meant to recieve from the front-end
        exp_keys = ['name', 'description', 'id']

        if not request.is_json:
            return jsonify({"error": "data must be JSON"}), 400

        data = request.get_json()
        missing = [k for k in exp_keys if k not in data]
        if missing:
            return jsonify({"error": f"missing keys: {missing}"}), 400


        # check for missing data
        if not isinstance(data["name"], str) \
           or not isinstance(data["description"], str) \
           or not isinstance(data["id"], int):
            return jsonify({"error": f'wrong data types - {data}'}), 400


        # Grabbing the task if it exists
        tid = data['id']
        task = current_user.tasks.filter(Task.id == tid).first()
        if not task:
            return jsonify({"error": "Task not found or does not belong to current user"}), 404


        # Making the changes to the task
        task.name = data['name']
        task.description = data['description']
        db.session.commit()
        return jsonify({"message": "Task updated!"}), 200


@task_bp.route("/delete/<int:id>", methods=["DELETE"])
@login_required
def delete_task(id):
    """
    Delete the task with the specified ID.
    Returns an error if the task is not found.
    """
    task = current_user.tasks.filter(Task.id == id).first()
    if task is None:
        return jsonify({"error": "Task not found!"}), 404
    db.session.delete(task)
    db.session.commit()
    return jsonify({"message": "Task deleted!"}), 200



@task_bp.route('/getTasksLength/', methods=["GET"]) # type: ignore
@login_required
def amount_of_tasks():
    latestTaskId = db.session.execute(select(Task.id).where(Task.user_id == current_user.id).order_by(desc(Task.id))).scalars().first()
    print(latestTaskId)
    if latestTaskId:
        return jsonify({"amount": latestTaskId}), 200
    else:
        return jsonify({"error": "There are no Task entries under the current user"}), 404


@task_bp.route('/done/<int:id>', methods=["PATCH"])
@login_required
def completed_tasks(id):
    """
    Mark the specified task as done or not done.
    """
    if not request.is_json:
         return jsonify({"error": "invalid data, data needs to be inside json"}), 400

    data = request.get_json()

    # Update the 'done' attribute of the task.
    task = current_user.tasks.filter(Task.id == id).first()
    if not task:
        return jsonify({"error": f"The Task with the ID: {id} doesnt exist!"}), 404

    if 'bool' in data and isinstance(data["bool"], bool):
        task.done = data["bool"]
        db.session.commit()
        # Return a response with the updated task state.
        return jsonify({"message": f"Task done set as {data['bool']}!"}), 200
    else:
        return jsonify({"error": f'data doesnt have the correct key-value pair (bool:true|false) instead it has {data}'}), 400






===== .\focus_flow_app\routes\__init__.py =====
from .auth_routes import auth_bp
from .misc_routes import misc_bp
from .task_routes import task_bp

def register_routes(app):
    app.register_blueprint(auth_bp)
    app.register_blueprint(misc_bp)
    app.register_blueprint(task_bp)
===== .\focus_flow_app\static\css\mainPage.css =====
html {
    display: flex;
    flex-direction: column;
    align-items: center;
}

===== .\focus_flow_app\static\css\style.css =====
/*********************************************************************
 * File: style.css
 * Purpose: Contains all CSS rules for the FocusFlow App including:
 *   - Responsive layout adjustments
 *   - Task and button styling
 *   - Custom scrollbar styling
 *********************************************************************/

/* Responsive design for smaller screens */
@media (max-width: 900px) {
    .tasks {
        margin: 0; /* Remove margin for compact layout */
    }
    #task_label {
        margin-bottom: 20px; /* Adjust spacing below task label */
    }
    .task_done, .task_delete {
        width: 100%; /* Make buttons full width */
    }
    button, button:hover {
        font-size: 0.8em; /* Smaller font size on buttons */
        border-color: #fff;
    }
    .focusFlow_task_list {
        flex-direction: column; /* Stack task list vertically */
    }
}

/* Custom scrollbar styling */
::-webkit-scrollbar {
    width: 5px;
    height: 5px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background-color: #fff;
    border-radius: 10px;
}

/* Global body styling */
body {
    background-color: #f0f0f0; /* Light grey background */
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
}

/* Style for the Add Task button */
#focusFlow_task_add_button {
    background-color: #333;  /* Dark background */
    border: none;
    color: #fff;
    cursor: pointer;
    margin-top: 5px;
    padding: 5px;
    width: 100%;
}

/* Header and task styling */
head {
    margin: 0;
    padding: 0;
}

header {
    background-color: #333;  /* Dark header */
    color: #fff;
    padding: 10px 0;
    text-align: center;
}

.tasks {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 2px; /* Spacing between tasks */
    border: 8px solid #1a1a1a; /* Task border */
    text-align: center;
    padding: 10px;
    width: 188px;
    height: 320px;
}

#task_label {
    font-size: 1.7em;
    margin-bottom: auto;
}

#focusFlow_task_list {
   display: flex;
   flex-direction: row;
   align-items: center;
   flex-wrap: nowrap;
   overflow-x: auto;
}

/* Button styling for task actions */
.task_done, .task_delete, .task_edit {
    background-color: #333;
    border: solid black;
    color: #fff;
    cursor: pointer;
    margin-top: 5px;
    padding: 5px;
    width: 50%;
}

/* Styling for the task description area */
.description {
    background-color: gray;
    color: black;
    width: 85%;
    height: 25%;
    border: 4px solid #333;
    overflow-y: auto;
    overflow-x: hidden;
}

/* Styling for dialog inputs */
#new_task_form, #edit_task_form {
    display: flex;
    flex-wrap: nowrap;
    flex-direction: column;
    justify-content: center;
    min-width: 240px;
    min-height: 375px;
}

#input_dialog textarea,
#input_dialog input,
#edit_tasks textarea,
#edit_tasks input {
    margin-bottom: 12px;
}

#input_dialog textarea,
#edit_tasks textarea {
    width: 97%;
    height: 195px;
    resize: vertical;
}

#new_task_dialog_label,
#edit_task_dialog_label {
    text-align: center;
    font-size: larger;
    text-decoration: underline;
    margin-bottom: 12px;
}

===== .\focus_flow_app\static\js\homeJSLogic.js =====
/** This file simply build the UI logic for the home page */

const loginBtn = document.getElementById('login');
const signupBtn = document.getElementById('signup');


const buttons = document.getElementsByClassName('button')
const buttonsArray = [...buttons];

buttonsArray.forEach(element => {
    element.addEventListener('click', (e) => {
        e.preventDefault();
        if (element.id === 'login') {
            window.location.href = '/auth/login_page';
        }
        else {
            window.location.href ='/auth/signup';
        };
    })

});
===== .\focus_flow_app\static\js\logic.js =====
/**********************************************************************
 * File: logic.js
 * Purpose: Contains client-side logic for task management including:
 *   - Fetching tasks from the server
 *   - Creating, editing, deleting, and marking tasks as done
 *   - Syncing task state with the backend server
 **********************************************************************/

// Purpose: Define the client-side logic for the task management system

// Listener for DOM content load ‚Äì initializes the task manager when the document is ready.
document.addEventListener('DOMContentLoaded', () => {
    let domain = window.location.origin;
    console.log(domain)

    // DOM is fully loaded; initialize task manager variables and event listeners.
    let focusFlow_task_list = document.getElementById('focusFlow_task_list'); // Container for tasks
    let focusFlow_task_add = document.getElementById('focusFlow_task_add_button'); // Button to add new tasks
    let task_counter = document.getElementById('amount_of_tasks'); // Displays count of tasks
    let task_list = document.getElementsByClassName('tasks'); // Collection of task items
    /**
     * Fetch tasks from the server and add them to the DOM.
     * Uses a GET request and iterates over the returned JSON data.
     */
    const get_tasks = () => {
        // Clear current task list in the DOM.
        task_list.innerHTML = '';
        fetch(`${domain}/task/dashboard`, {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            data.forEach((task, idex) => {
                make_task_gui(task.name, task, task.description, idex);
            })
        })
        .catch(error => {
            console.error('Error:', error);
        })
    };


    /**
     * Delete a task on the server via a DELETE request.
     * @param {string|number} task - The unique task ID.
     */
    const delete_tasks = (task) => {
        fetch(`${domain}/task/delete/${task}`, {
            method: 'DELETE',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            console.log(data);
        })
        .catch(error => {
            console.error('Error:', error);
        })
    };


    // Returns a promise resolving to the number of tasks in the database.
    const get_amount_of_db_tasks = async () => {
        return fetch(`${domain}/task/getTasksLength/`, {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Cache-Control': 'no-cache',
                'Accept': 'application/json'
            }

        })
        .then(response => {
            if (!response.ok) {
                throw new Error('network response was not okay!')
            }
            return response.json();
        })
        .then(data => {
            console.log(data)
            return data['amount'];
        })
        .catch(error => {
            console.error('Error', error);
            return 0;
        })
    };

    /**
     * Sends raw new task JSON data to the server using the form's action.
     * @param {FormData} form - Form data.
     * @param {string} id - Task ID.
     */
    const send_tasks = (form, id=0) => {
        let formData = new FormData(form);
        let data = {};
        formData.forEach((value, key) => {
            console.log(key, value)
            data[key] = value
        });
        data['id'] = Number(id);

        const method = form.getAttribute('data-method') || form.method;

        fetch(form.action, {
            method: method, // Use configured HTTP method.
            body: JSON.stringify(data),
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            console.log(data);
        })
        .catch(error => {
            console.error('Error:', error);
        })
    };



    /**
     * Sends a PATCH request to mark a task as done or not done.
     * @param {string|number} task_id - Unique ID of the task.
     * @param {Object} value - Object containing the done state.
     */
    const done_tasks = (task_id, value) => {
        fetch(`${domain}/task/done/${task_id}`, {
            method: 'PATCH',
            credentials: 'include',
            body: JSON.stringify(value),
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if(!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => console.log(data)) // Log successful update.
        .catch(error => console.error(error));
    };



    /**
     * Toggle the done state of a task.
     * Sets appropriate event listeners and adjusts styling.
     */
    const switchBtn = (elbutton, value) => {

        const onFalseClick = () => {
            const val = {'bool': false};
            elbutton.parentElement.style.textDecoration = '';
            elbutton.parentElement.style.color = 'black';
            task_amount();
            done_tasks(elbutton.parentElement.getAttribute('dbid'), val);
            elbutton.removeEventListener('click', onFalseClick);
            elbutton.addEventListener('click', onTrueClick);
        };

        const onTrueClick = () => {
            const val = {'bool': true};
            // Update visual style to indicate task completion.
            elbutton.parentElement.style.textDecoration = 'line-through';
            elbutton.parentElement.style.color = 'gray';
            task_amount();

            done_tasks(elbutton.parentElement.getAttribute('dbid'), val);
            elbutton.removeEventListener('click', onTrueClick);
            elbutton.addEventListener('click', onFalseClick);
        };

        if (value == false) {
            elbutton.addEventListener('click', onFalseClick);
        } else if (value == true) {
            elbutton.addEventListener('click', onTrueClick);
        }
    };

    /**
     * Attaches event listeners to "Done" buttons.
     * Applies done styling if the task is already completed.
     */
    const done_task_buttons = (buttons) => {
        for (let button of buttons) {
            // Avoid duplicate event listeners.
            if (!button.hasAttribute('isLinked')) {
                button.setAttribute('isLinked', 'true');
                if (button.parentElement.done) {
                    button.parentElement.style.textDecoration = 'line-through';
                    button.parentElement.style.color = 'gray';
                    switchBtn(button, false);
                } else {
                    switchBtn(button, true);
                }
            } else {
                continue;
            }
        }
    };

    /**
     * Iterates over delete buttons and attaches click event listeners.
     * Upon clicking, the task is removed from the DOM and the server.
     * @param {HTMLCollection} buttons - Collection of delete buttons.
     */
    const remove_task_buttons = (buttons) => {
        for (let button of buttons) {
            if (!button.hasAttribute('isLinked')) {
                button.setAttribute('isLinked', 'true');
                button.addEventListener('click', () => {
                    // Extract task ID and remove task element.
                    console.log(button.parentElement.getAttribute('dbId'));
                    button.parentElement.remove();
                    delete_tasks(button.parentElement.getAttribute('dbId'));
                    task_amount(); // Update counter after deletion.
                });
            }
        }
    };

    /**
     * Attaches click event listeners to "Edit" buttons.
     * Opens the task editor dialog on activation.
     * @param {HTMLCollection} buttons - Collection of edit buttons.
     */
    const edit_task_buttons = (buttons) => {
        for (let button of buttons) {
            if (!button.hasAttribute('isLinked')) {
                button.setAttribute('isLinked', 'true');
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    const task = button.parentElement;
                    edit_tasks_gui(task);
                });
            } else {
                continue;
            }
        }
    };

    /**
     * Updates the task counter displaying total and completed tasks.
     */
    const task_amount = () => {
        let tasks = document.getElementsByClassName('tasks'); // Get current task elements.
        let amount = tasks.length;
        let amount_done = 0;

        for (let task of tasks) {
            if (task.style.textDecoration === 'line-through') {
                amount_done++;
            }
        }
        task_counter.textContent = `${amount}/${amount_done}`;
    };

    /**
     * Creates a new task DOM element and appends it to the task list.
     * @param {string} name - Name of the task.
     * @param {Object|null} dbtask - Task object from the database.
     * @param {string|null} taskDiscription - Optional task description.
     */
    async function make_task_gui(name, dbtask=null, taskDiscription=null, idex=null, taskList=task_list) {
        let task = document.createElement('div'); // Create container for the task.
        if (dbtask != null) {
            task.id = `task_${idex}`;
            task.setAttribute('dbId', dbtask.id)
            task.name = dbtask.name;
            task.done = dbtask.done;
            task.classList.add('tasks');
            task.innerHTML = `
                <label id=task_label for="${task.id}">${dbtask.name}</label>
                <p id="description_${task.id}" class="description">${dbtask.description || ''}</p>
                <button class="task_edit" type="button" aria-label="edit_${task.name}">Edit</button>
                <button class="task_done" type="button" aria-label="done_${task.name}">Done</button>
                <button class="task_delete" type="button" aria-label="delete_${task.name}">Delete</button>
            `;
            focusFlow_task_list.appendChild(task); // Add task to the list.
            remove_task_buttons(document.getElementsByClassName('task_delete'));
            done_task_buttons(document.getElementsByClassName('task_done'));
            edit_task_buttons(document.getElementsByClassName('task_edit'));
            task_amount(); // Update task counter.

        } else {
            task.id = `task_${taskList && taskList.length ? taskList.length : 0}`;
            task.setAttribute('dbId', await get_amount_of_db_tasks())
            task.name = name;
            task.done = false;
            task.classList.add('tasks');
            task.innerHTML = `
                <label id=task_label for="${task.id}">${name}</label>
                <p id="description_${task.id}" class="description">${taskDiscription || ''}</p>
                <button class="task_edit" type="button" aria-label="edit_${task.name}">Edit</button>
                <button class="task_done" type="button" aria-label="done_${task.name}">Done</button>
                <button class="task_delete" type="button" aria-label="delete_${task.name}">Delete</button>
            `;
            focusFlow_task_list.appendChild(task);
            remove_task_buttons(document.getElementsByClassName('task_delete'));
            done_task_buttons(document.getElementsByClassName('task_done'), task.done);
            edit_task_buttons(document.getElementsByClassName('task_edit'));
            task_amount(); // Update task counter.
        }
    };

    /**
     * Opens a modal dialog to capture a new task's details.
     */
    const task_name_dialog = () => {
        let diag_box = document.createElement('dialog'); // Create dialog for user input.
        diag_box.id = 'input_dialog';

        let makeTaskForm = document.createElement('form');
        makeTaskForm.action = `${domain}/task/tasks`;
        makeTaskForm.id = 'new_task_form';
        makeTaskForm.method = 'POST';
        // Ensure the backend can handle both adding and editing tasks.

        let diag_box_label = document.createElement('label');
        diag_box_label.id = "new_task_dialog_label";
        diag_box_label.textContent = 'Add New Task';
        diag_box_label.htmlFor = 'input_dialog';
        makeTaskForm.appendChild(diag_box_label);

        // Create label and input for the task name.
        let label = document.createElement('label');
        label.textContent = 'Task Name';
        label.htmlFor = 'task_name_input_field';
        makeTaskForm.appendChild(label);

        let input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter task name';
        input.id = 'task_name_input_field';
        input.name = 'name';
        input.required = true;
        makeTaskForm.appendChild(input);

        // Create label and textarea for the task description.
        let discLabel = document.createElement('label');
        discLabel.textContent = 'Task description';
        discLabel.htmlFor = 'description';
        makeTaskForm.appendChild(discLabel);

        let discInput = document.createElement('textarea');
        discInput.placeholder = "Enter your task description...";
        discInput.id = 'description';
        discInput.name = 'description';
        discInput.required = true;
        makeTaskForm.appendChild(discInput);

        // Create submit button.
        let submitButton = document.createElement('button');
        submitButton.textContent = 'Submit';
        submitButton.id = 'submitBtn';
        submitButton.type = 'submit';
        makeTaskForm.appendChild(submitButton);

        // Create cancel button.
        let cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.type = 'button';
        makeTaskForm.appendChild(cancelButton);

        diag_box.appendChild(makeTaskForm);

        diag_box.addEventListener('keypress', (e) => {
            if (e.key === 'Esc') {
                diag_box.close();
                diag_box.remove();
            }
        });

        makeTaskForm.addEventListener('submit', (event) => {
            event.preventDefault();
            event.stopPropagation();

            send_tasks(makeTaskForm);
            make_task_gui(input.value, null, discInput.value);
            // Close dialog after processing the form.
            diag_box.close();
            diag_box.remove();
            task_amount(); // Refresh task count.
        });

        cancelButton.addEventListener('click', (event) => {
            event.preventDefault();
            diag_box.close();
            diag_box.remove();
        });

        document.body.appendChild(diag_box);
        diag_box.showModal(); // Show input dialog as modal.
        input.focus(); // Focus the task name field.
    };

    /**
     * Opens a modal dialog to edit an existing task.
     * Updates the backend after confirmation.
     * @param {HTMLElement} task - The task element to be edited.
     */
    const edit_tasks_gui = (task) => {
        console.log('B'); // Debug: edit dialog initiated.
        const edit_task_dialog = document.createElement('dialog');
        edit_task_dialog.id = 'edit_tasks';

        let diag_edit_label = document.createElement('label');
        diag_edit_label.id = "edit_task_dialog_label";
        diag_edit_label.textContent = 'Edit Task';
        diag_edit_label.htmlFor = 'edit_tasks';
        edit_task_dialog.appendChild(diag_edit_label);

        const editTaskForm = document.createElement('form');
        editTaskForm.action = `${domain}/task/tasks`;
        editTaskForm.setAttribute('data-method', 'PATCH');
        editTaskForm.id = 'edit_task_form';

        const task_name_field_label = document.createElement('label');
        task_name_field_label.textContent = 'Task Name';
        task_name_field_label.htmlFor = 'new_task_name_field';
        editTaskForm.appendChild(task_name_field_label);

        const task_name_field = document.createElement('input');
        task_name_field.required = true;
        task_name_field.type = 'text';
        task_name_field.value = task.name;
        task_name_field.id = 'new_task_name_field';
        task_name_field.name = 'name';
        editTaskForm.appendChild(task_name_field);

        // Label for Task Description.
        const task_decription_field_label = document.createElement('label');
        task_decription_field_label.textContent = 'Task Description';
        task_decription_field_label.htmlFor = 'new_task_paragraph_field';
        editTaskForm.appendChild(task_decription_field_label);

        const task_paragraph_field = document.createElement('textarea');
        task_paragraph_field.name = 'description';
        task_paragraph_field.required = true;
        task_paragraph_field.value = task.querySelector('.description').textContent;
        task_paragraph_field.id = 'new_task_paragraph_field';
        editTaskForm.appendChild(task_paragraph_field);

        const confirmBtn = document.createElement('button');
        confirmBtn.type = 'submit';
        confirmBtn.id = 'confirmBtn';
        confirmBtn.textContent = "Confirm";
        editTaskForm.appendChild(confirmBtn);

        let cancelBtn = document.createElement('button');
        // Setup cancel button for the edit dialog.
        cancelBtn.type = 'button';
        cancelBtn.id = 'cancelBtn';
        cancelBtn.textContent = 'Cancel';
        editTaskForm.appendChild(cancelBtn);

        edit_task_dialog.addEventListener('keypress', (e) => {
            if (e.key === 'Esc') {
                edit_task_dialog.close();
                edit_task_dialog.remove();
            }
        });

        // Confirm edit: update task data and UI.
        editTaskForm.addEventListener('submit', async(e) => {
            e.preventDefault();
            send_tasks(editTaskForm, task.getAttribute('dbid'));
            edit_task_dialog.close();
            edit_task_dialog.remove();
            // Update task element with new values.
            task.querySelector('.description').textContent = task_paragraph_field.value;
            task.querySelector('#task_label').textContent = task_name_field.value;
        });

        // Cancel edit if requested by the user.
        cancelBtn.addEventListener('click', (e) => {
            e.preventDefault();
            edit_task_dialog.close();
            edit_task_dialog.remove();
        });

        edit_task_dialog.appendChild(editTaskForm);
        document.body.appendChild(edit_task_dialog);
        edit_task_dialog.showModal(); // Show edit dialog.
    };

    // Attach click listener to "Add Task" button.
    focusFlow_task_add.addEventListener('click', (event) => {
        event.preventDefault();
        task_name_dialog();
    });

    get_tasks(); // Retrieve tasks from the server.
    task_amount(); // Update task counter after initialization.
}); // End of DOMContentLoaded event listener
===== .\focus_flow_app\static\js\loginJSLogic.js =====
/**
 * loginJSLogic.js
 *
 *
 * This file at the current time is used to clear flash messages from
 * login_page after 5000 miliseconds(5 seconds)...
 */


const flashMessage = document.getElementById('notification');



setTimeout(() => {
    flashMessage.remove()
}, 5000);

===== .\focus_flow_app\templates\base.html =====
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>{% block title %}FocusFlow{% endblock %}</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
        {% block head %}{% endblock %}
    </head>
    <body>
        <header>
            <h1><a href="{{ url_for('main.load_landing_page') }}">FocusFlow</a></h1>
            {% if current_user.is_authenticated %}
            <form action="{{ url_for('auth.logout') }}" method="post">
                <button id="logoutBtn" type="submit">Logout</button>
            </form>
            {% endif %}
        </header>


        <main>
            {% block content %}{% endblock %}
        </main>

        <footer>
            <p>&copy; 2025 FocusFlow</p>
        </footer>

        {% block scripts %}{% endblock %}
    </body>
</html>
===== .\focus_flow_app\templates\dashboard.html =====
{% extends "base.html" %}
{% block title %}Dashboard - FocusFlow{% endblock %}
{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css')}}">
{% endblock %}
{% block content %}
    <div class="container">
        <header>

            <h1>Dashboard</h1>

            <h3 id="amount_of_tasks"></h3>
        </header>

        <button id="focusFlow_task_add_button" type="button">Add Task</button>

        <div id="focusFlow_task_list">
            <!-- Task items will be inserted here dynamically -->
        </div>

    </div>
{% endblock %}
{% block scripts %}
    <script src="{{ url_for('static', filename='js/logic.js')}}"></script>
{% endblock %}
===== .\focus_flow_app\templates\home.html =====
{% extends "base.html" %}
{% block title %}FocusFlow{% endblock %}
{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mainPage.css')}}">
{% endblock %}
{% block content %}
    <h1>Your One Stop Task Managment Website</h1>
    <button class='button' id="login">Login</button><button class='button' id="signup">Sign Up</button>
{% endblock %}
{% block scripts %}
    <script src="{{ url_for('static', filename='js/homeJSLogic.js')}}"></script>
{% endblock %}
===== .\focus_flow_app\templates\login.html =====
{% extends "base.html" %}
{% block title %}Login - FocusFlow{% endblock %}
{% block content %}
    <h2>Login Page</h2>
    {% with messages = get_flashed_messages() %}
    {% if messages %}
    <ul id="notification">
        {% for m in messages %}
        <li style="color: red; font-weight: bold; text-shadow: 1px 1px gray; border: solid 2px black; padding: 8px; background-color: #fff0f0;">{{m}}</li>
        {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}

    <form action="{{ url_for('auth.login_page') }}" method="post">
        <label for="userEmail">Enter Your Email</label>
        <input id="userEmail" type="email" name="user_email" autocomplete="off" required />

        <label for="userPassword">Enter Your Password</label>
        <input id="userPassword" type="password" name="user_password" autocomplete="off" required />
        <p id="newAccountSpan">
            havent got an account?
            <a id="newAccountLink" href="{{ url_for('auth.create_New_User_Account') }}">sign up</a>
        </p>
        <button type="submit">submit</button>
    </form>
{% endblock %}
{% block scripts %}
    <script src="{{ url_for('static', filename='js/loginJSLogic.js') }}"></script>
{% endblock %}
===== .\focus_flow_app\templates\signup.html =====
{% extends "base.html" %}
{% block title %}Signup - FocusFlow{% endblock %}
{% block content %}
    <h1>Create Account</h1>
    <form action="{{ url_for('auth.create_New_User_Account') }}" method="post">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                <ul>
                {% for m in messages %}
                    <li style="color: red;">{{m}}</li>
                {% endfor %}
                </ul>
            {% endif %}
        {% endwith %}

        <label>Username</label>
        <input id="userSignUpUsername" type="text" name="user_name" autocomplete="off" required />

        <label >Email</label>
        <input id="userSignUpEmail" type="Email" name="user_email" autocomplete="off" required />

        <label>Password</label>
        <input id="userSignUpPassword" type="password" name="user_password" autocomplete="off" required />

        <button id="confirmBtn" type="submit">Submit</button>
    </form>

{% endblock %}

===== .\tests\server__test.py =====
import unittest
from focus_flow_app import create_app
from sqlalchemy import select
from flask_login import logout_user
from focus_flow_app.routes.task_routes import validator
from focus_flow_app.models import Task, db

class FlaskServerTest(unittest.TestCase):
    """This class is for our backend.py server's unit tests"""
    def setUp(self):
        '''setUp this module runs before every test is executed'''
        self.app = create_app("testing") # type: ignore

        # Initalise the test client from our Flask App...
        self.client = self.app.test_client()
        # Push the app context, in otherwords ensure the app is the current one being pointed to...
        self.ctx = self.app.app_context()
        self.ctx.push()
        db.create_all()

        resp = self.client.post(
            "/auth/signup",
            data={"user_name": "testUser", "user_email": "testUser@gmail.com", "user_password": "testPassword"},
            follow_redirects=True
        )


        with self.client.session_transaction() as sess:
            id = int(sess["_user_id"])


        self.current_user_id = id

        self.assertEqual(resp.status_code, 200)


    def tearDown(self):
        '''tearDown this module runs after every test is excuted'''
        # We drop and remove the tables before the next unit test
        db.session.remove()
        db.drop_all()
        # Removes the app context but doesnt remove the app itself...
        self.ctx.pop()


    def create_test_task(self, name="test_name", description="test_description"):
        '''This function creates a testing Task to be used in the unit tests.'''
        test_task = Task(user_id=self.current_user_id, name=name, description=description) # type: ignore
        db.session.add(test_task)
        db.session.commit()
        return test_task


    def test_Root_Address(self):
        '''This is a unit test for checking our root address "/" is accessible via GET'''
        response = self.client.get('/')
        self.assertEqual(response.status_code, 200 or 304, 'root address "/" was not accessed.')


    def test_Give_Tasks(self):
        '''This unit test checks that our dashboard is loaded correctly'''
        response = self.client.get('/task/dashboard')
        self.assertEqual(response.status_code, 200, '"/dashboard.html" failed to load correctly!')


    def test_Add_Task_To_Database(self):
        '''This unit test is used to check that we can add tests to our database via POST'''
        response = self.client.post('/task/tasks', json={'name': 'test name', 'description': 'testdescription', 'id': 0})
        self.assertEqual(response.status_code, 201, 'the task failed to be added in add_tasks()')


    def test_Add_Task_To_Database_Invalid_Input_Not_Json(self):
        '''This unit test checks that the body part of the response for adding tasks contains json'''
        response = self.client.post('/task/tasks', data={'name': 'test_name', 'description': 'test_description'})
        self.assertEqual(response.status_code, 400, 'the error logic for checking if the response contains json in add_tasks() failed')


    def test_Add_Task_To_Database_Invalid_Input_Missing(self):
        '''This unit test runs if the required data isnt given'''
        response = self.client.post('/task/tasks', json={'name': True, 'description': False})
        self.assertEqual(response.status_code, 422, 'the error logic for the validator() logic in "add_tasks()" failed')


    def test_Edit_Task_In_Database(self):
        '''This unit test checks that we can edit tasks by their id from the database using PATCH'''
        self.create_test_task()
        response = self.client.patch('/task/tasks', json={'task_name': 'test_name', 'task_description': 'test_description', 'id': 1, 'user_id': self.current_user_id})
        self.assertEqual(response.status_code, 200, 'the edit of the task within the PATCH call of add_tasks() has failed.')


    def test_Edit_Task_In_Database_Not_Json(self):
        '''This unit test ensures we are passing json in the body from send_tasks() else it fails'''
        response = self.client.patch('/task/tasks', data={'not_json': 'not json either'})
        self.assertEqual(response.status_code, 400, 'the error logic inside of the PATCH branch of add_tasks() that checks if the data is in has failed')


    def test_Edit_Task_In_Database_Missing_Data(self):
        '''This unit test checks if the send_tasks() function is passing all the required data'''
        response = self.client.patch('/task/tasks', json={'task_name': 'test_name', 'task_description': 'test_description', 'id': '1', 'user_id': self.current_user_id})
        self.assertEqual(response.status_code, 400, 'invalid! Missing Data from client!')


    def test_Delete_Task(self):
        '''This unit test checks that we can correctly delete tasks from the database via their ID'''
        test_task = self.create_test_task()

        stmt = select(Task).where(Task.name == test_task.name)
        result = db.session.execute(stmt).scalar_one_or_none()

        if result:
            task_id = str(result.id)
        else:
            task_id = None

        response = self.client.delete(f'/task/delete/{task_id}')
        self.assertEqual(response.status_code, 200, f"The Task with the ID:{task_id} does not exist! thus could not be deleted.")

        tasks = Task.query.all()
        self.assertNotIn(test_task, tasks, f"The Task with ID:{task_id} was not deleted!")


    def test_Delete_Task_Bad_Id(self):
        '''This unit test ensures when a Id for a task that doesnt exist is sent its caught'''
        response = self.client.delete(f'/task/delete/00')

        isTask = db.session.execute(select(Task).where(Task.id == 00)).scalar_one_or_none()
        self.assertIsNone(isTask, 'The Task with the provided ID: 00 doesnt exist. thus cant be deleted.')

        self.assertEqual(response.status_code, 404, 'deletion fail! the Task with the provided ID:00 does not exist!')


    def test_Amount_Of_Tasks(self):
        '''This unit test gets the amount of Task entries we have in our database for our current user'''
        self.create_test_task()
        response = self.client.get('/task/getTasksLength/')
        self.assertEqual(response.status_code, 200, 'failed to get the amount of Task entries for the current user!')


    def test_Amount_Of_Tasks_Fail(self):
        '''This unit test ensures we get notified if our Task table has no entries under the current user'''
        response = self.client.get('/task/getTasksLength/')
        self.assertEqual(response.status_code, 404, 'we arent capturing when theres no task entries in getTasksLength for the current user')


    def test_Done_Tasks(self):
        '''This unit test checks that the server is reciving the expect datatype ie JSON from done_tasks'''
        self.create_test_task()
        response = self.client.patch('/task/done/1', json={'bool': True})
        self.assertEqual(response.status_code, 200, "The task with ID:1 was unable to be marked as done in the '/task/done' route!")


    def test_Done_Tasks_Invalid_Data(self):
        '''This unit test ensures we get an error if the datatype isnt JSON from done_task'''
        response = self.client.patch('/task/done/1', data={'invalid_key': 'invalid_value'})
        self.assertEqual(response.status_code, 400, "The '/task/done' route is not correctly catching if the data sent to it isnt JOSN!")


    def test_Done_Tasks_No_Such_Task(self):
        '''This unit test gives us an error if done_tasks gives us an ID that isnt linked to a task'''
        response = self.client.patch('/task/done/00', json={"bool": True})
        self.assertEqual(response.status_code, 404, "invalid! no task with ID: 00 exists")


    def test_Done_Tasks_Invalid_KeyPair(self):
        '''This unit test gives us an error if our server recivies an incorrect key-value pair from done_tasks'''
        self.create_test_task()
        response = self.client.patch('/task/done/1', json={'bool': None})
        self.assertEqual(response.status_code, 400, "we are no longer catching incorrect key-value pairs from done_tasks!")


    def test_Create_User_Invalid_Key_Value_Input(self):
        '''This unit test ensures we are catching if an incorrect key_pair is being
        provided by our signup form.'''
        response = self.client.post("/auth/signup", data={"name": "test_name", "user_email": "test@email", "userpassword": "pass"})
        self.assertEqual(response.status_code, 422, "an invalid key-pair isnt being reported when creating a new account!")


    def test_Create_User_invalid_key_value_empty_input(self):
        '''This unit test ensures we are catching if an empty key_pair is being
        provided by our signup form.'''
        response = self.client.post("/auth/signup", data={"user_name": "", "user_email": "", "user_password": ""})
        self.assertEqual(response.status_code, 422, "An empty key-pair isnt being reported when creating a new account!")


    def test_Create_User_valid(self):
        '''This unit test ensures our create user route is correctly
        executing when its being given the correct data'''
        response = self.client.post("/auth/signup", data={"user_name": "testName", "user_email": "testEmail@gmail.com", "user_password": "testUserPassword"})
        self.assertEqual(response.status_code, 302, "Our create user route failed on correct data!")


    def test_Login_User_valid(self):
        '''This unit test tests for the successful case of our user login'''
        response = self.client.post("/auth/login_page", data={"user_email": "testUser@gmail.com", "user_password": "testPassword"}, follow_redirects=True)
        self.assertNotIn(b'Incorrect password', response.data, "The test user was not able to sign in as expected!")
        self.assertNotIn(b'A user with that email:', response.data, "The test user was not able to sign in as expected!")
        self.assertIn(b'Dashboard', response.data, "The test user was not able to sign in as expected!")


    def test_Login_User_Invalid_Password(self):
        '''This unit test tests for the unsuccessful case of our user login where the password does not match'''
        response = self.client.post("/auth/login_page", data={"user_email": "testUser@gmail.com", "user_password": "wrongtestPassword"}, follow_redirects=True)
        self.assertIn(b'Incorrect password!', response.data, "The test password was incorrect but not caught!")


    def test_Login_User_Invalid_Email(self):
        '''This unit test tests for the unsuccessful case of our user email not existing in the database'''
        response = self.client.post("/auth/login_page", data={"user_email": "noneExistantTestUser@gmail.com", "user_password": "testPassword"}, follow_redirects=True)
        self.assertIn(b'A user with the email:', response.data, "The test email was not pressent in the database but didnt fail!")


    def test_Logout_User_Valid(self):
        '''This unit test ensures that our logout route is functioning as expected'''
        response = self.client.post("/auth/logout")
        self.assertEqual(response.status_code, 303, "The logout for the current user failed!")



# Initalisation
if __name__ == '__main__':
    unittest.main()

===== .\tests\__init__.py =====
